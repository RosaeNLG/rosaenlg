= Tutoriel RosaeNLG pour g√©n√©rer du fran√ßais

:rosaenlg_lang: fr_FR

++++
<script>
const currentLang = 'fr_FR';
</script>
++++

== Objectifs

Ce tutoriel donne un premier aper√ßu de RosaeNLG. Vous apprendrez √† utiliser RosaeNLG pour g√©n√©rer des textes d√©crivant des t√©l√©phones OnePlus.

Il ne s'agit pas d'un tutoriel link:https://pugjs.org/[Pug] - une connaissance basique de Pug est n√©cessaire en pr√© requis.

Les donn√©es des t√©l√©phones OnePlus proviennent de link:https://www.phonearena.com/phones/compare/OnePlus-5T,OnePlus-5,OnePlus-3T/phones/10695,10501,10313[ce site].

== Mise en place de l'environnement Node

TIP: Ce tutoriel fait du rendu c√¥t√© serveur avec node.js. Mais vous pouvez aussi faire du rendu c√¥t√© client, xref:browser:intro.adoc[directement dans le navigateur].

TIP: L'√©diteur int√©gr√© vous permettra d'ex√©cuter aussi directement le tutoriel dans votre navigateur.

Vous pouvez passer cette partie si vous √™tes familier avec l'environnement node.js.

* installer `node.js` et `npm`
* cr√©er un r√©pertoire `tutoriel` quelque part
* `npm init` et accepter toutes les r√©ponses propos√©es par d√©faut
* `npm install rosaenlg` va t√©l√©charger RosaeNLG ; l'installation se terminera par `+ rosaenlg@x.x.x`
* cr√©er un fichier `tuto.js`, et mettre `console.log("hello NLG");` √† l'int√©rieur
* `node tuto.js` devrait g√©n√©rer `hello NLG` (ok ce n'est pas vraiment de la Natural Language Generation pour l'instant)

== Donn√©es initiales

Les donn√©es initiales. Mettez-les dans le fichier `tuto.js`.
[source,javascript]
....
include::partial$tuto_fragments.js[tags=data]
....

++++
<script>
const phoneString = `-
  let phones = [
    {
      name: 'OnePlus 5T',
      colors: ['Black', 'Red', 'White'],
      displaySize: 6,
      screenRatio: 80.43,
      battery: 3300
    },
    {
      name: 'OnePlus 5',
      colors: ['Gold', 'Gray'],
      displaySize: 5.5,
      screenRatio: 72.93,
      battery: 3300
    },
    {
      name: 'OnePlus 3T',
      colors: ['Black', 'Gold', 'Gray'],
      displaySize: 5.5,
      screenRatio: 73.15,
      battery: 3400
    }
  ];
`
</script>
++++



== Plomberie & premiers textes

Vous avez besoin de la librairie `rosaenlg`. Pour cela ajoutez la ligne suivante tout au d√©but de votre fichier `tuto.js` :
[source,javascript]
....
include::partial$tuto_fragments.js[tags=require]
....

Dans le m√™me fichier, faites un rendu d'un template Pug (nous allons cr√©er le template juste apr√®s) :
[source,javascript]
....
let res = rosaenlgPug.renderFile('tuto.pug', {
    language: 'fr_FR',
    phone: phones[0],
    cache: true
});
console.log( res );
....
Cela g√©n√®rera un rendu du template `tuto.pug`. Les param√®tres sont les suivants :

* choisir une langue (ici `language: 'fr_FR'`) est obligatoire. 
* `cache: true` indique √† Pug qu'il ne doit pas recompiler le template √† chaque appel (en pratique l'ex√©cution sera plus rapide).
* vous pouvez organiser librement les autres propri√©t√©s ; ici nous avons simplement un propri√©t√© `phone` avec le premier t√©l√©phone de la liste.


Cr√©ez un fichier `tuto.pug` avec ce contenu:
....
p #{phone.name}
....
Ce 1er template est de la syntaxe Pug standard: nous affichons le nom du t√©l√©phone.

Quand vous faites un rendu du template (avec `node tuto.js`) vous devriez avoir: +
_OnePlus 5T_

_(ok, ce n'est toujours pas vraiment de la NLG pour l'instant)_


++++
<script>
spawnEditor(currentLang, 
`${phoneString}

- let phone = phones[0];
p #{phone.name}
`, 'OnePlus 5T'
);
</script>
++++



== Lister des √©l√©ments avec la structure `eachz`

Parlons des couleurs du t√©l√©phone: nous voulons g√©n√©rer __Les couleurs disponibles pour ce t√©l√©phone sont aaa, bbb and ccc._

Cr√©ez un mixin d√©di√© au listage des couleurs (dans votre fichier `tuto.pug`):
....
mixin colors
  | les couleurs disponibles pour ce t√©l√©phone sont
  eachz color in phone.colors with { separator:',', last_separator:'et', end:'.' }
    | #{color}
....

* `eachz` est une structure RosaeNLG, similaire √† une boucle foreach avec des capacit√©s de NLG.
* `{ separator:',', last_separator:'and', end:'.' }` indique √† `eachz` que:
** le s√©parateur standard est la virgule
** `et` doit √™tre utilis√© entre les 2 derni√®res couleurs
** il faut terminer avec un point

Appelez le mixin:
....
p #{phone.name} . #[+colors]
....

Lancez l'ex√©cution. Le r√©sultat doit √™tre : _OnePlus 5T. Les couleurs disponibles pour ce t√©l√©phone sont Black, Red et White._

Les espacements entre les mots ainsi que la mise en majuscule a √©t√© g√©r√©e automatiquement par RosaeNLG. Le nom de cette op√©ration est "r√©alisation de surface" en NLG.

TIP: √Ä pr√©sent nous faisons vraiment de la Natural Language Generation üöÄ

Il est pr√©f√©rable d'avoir les noms de couleur en fran√ßais. D√©finissez les correspondances:
....
  eachz color in phone.colors with { separator:',', last_separator:'et', end:'.' }
    -
      const colorMapping = {
        'Black': 'Noir',
        'Red': 'Rouge',
        'White': 'Blanc',
        'Gold': 'Or',
        'Gray': 'Gris'
      }
    | #{colorMapping[color]}
....

Le r√©sultat doit √™tre : _OnePlus 5T. Les couleurs disponibles pour ce t√©l√©phone sont Noir, Rouge et Blanc._.

++++
<script>
spawnEditor(currentLang, 
`${phoneString}

- let phone = phones[0];

mixin colors
  | les couleurs disponibles pour ce t√©l√©phone sont
  eachz color in phone.colors with { separator:',', last_separator:'et', end:'.' }
    -
      const colorMapping = {
        'Black': 'Noir',
        'Red': 'Rouge',
        'White': 'Blanc',
        'Gold': 'Or',
        'Gray': 'Gris'
      }
    | #{colorMapping[color]}

p #{phone.name} . #[+colors]
`, 'couleurs disponibles'
);
</script>
++++


== Boucler sur tous les t√©l√©phones

G√©n√©rons du texte pour chaque t√©l√©phone. Dans le fichier `tuto.js`:
[source,javascript]
....
let res = rosaenlgPug.renderFile('tuto.pug', {
    language: '{rosaenlg_lang}',
    phones: phones, // tous les t√©l√©phones
    cache: true
});
console.log( res );
....

Dans `tuto.pug` :
....
- let phone;
each phoneElt in phones
  - phone = phoneElt;
  p #{phone.name} . #[+colors]
....

WARNING: Ici nous avons mis directement la boucle dans le template Pug. Il est pr√©f√©rable, pour des cas r√©els, de boucler en-dehors (directement dans le JavaScript appelant), car cela permet de faire une remise √† z√©ro de RosaeNLG et de Pug entre chaque texte, ce qui est tr√®s nettement meilleur pour les performances.

Vous devriez obtenir: +
_OnePlus 5T. Les couleurs disponibles pour ce t√©l√©phone sont Noir, Rouge et Blanc._ +
_OnePlus 5. Les couleurs disponibles pour ce t√©l√©phone sont Or et Gris._ +
_OnePlus 3T. Les couleurs disponibles pour ce t√©l√©phone sont Noir, Or et Gris._

++++
<script>
const mainString = `
${phoneString}

BEFORE

- let phone;
each phoneElt in phones
  - phone = phoneElt;
  MAIN
`;

const mixinColorsString =
`mixin colors
  | les couleurs disponibles pour ce t√©l√©phone sont
  eachz color in phone.colors with { separator:',', last_separator:'et', end:'.' }
    -
      const colorMapping = {
        'Black': 'Noir',
        'Red': 'Rouge',
        'White': 'Blanc',
        'Gold': 'Or',
        'Gray': 'Gris'
      }
    | #{colorMapping[color]}
`;

spawnEditor(currentLang,
  mainString.replace('BEFORE', mixinColorsString)
    .replace('MAIN', 
    `p #{phone.name} . #[+colors]`),
  'Les couleurs disponibles pour ce t√©l√©phone sont Or et Gris'
);
</script>
++++


== Synonymes simples

Les lecteurs ont tendance √† pr√©f√©rer des textes non r√©p√©titifs. Ajoutons quelques synonymes simples: _teintes_ et _finitions_ sont des synonymes de _couleurs_ dans ce contexte.

Modifiez votre mixin `colors`:
....
mixin colors
  | les #[+syn('couleurs', 'teintes', 'finitions')] disponibles pour ce t√©l√©phone sont
  ...
....

Lancez l'ex√©cution √† plusieurs reprises et vous aurez des r√©sultats diff√©rents.

++++
<script>
const mixinColors2String =
`mixin colors
  | les #[+syn('couleurs', 'teintes', 'finitions')] disponibles pour ce t√©l√©phone sont
  eachz color in phone.colors with { separator:',', last_separator:'et', end:'.' }
    -
      const colorMapping = {
        'Black': 'Noir',
        'Red': 'Rouge',
        'White': 'Blanc',
        'Gold': 'Or',
        'Gray': 'Gris'
      }
    | #{colorMapping[color]}
`;

spawnEditor(currentLang,
  mainString.replace('BEFORE', mixinColors2String)
    .replace('MAIN', 
    `p #{phone.name} . #[+colors]`
  ),
  'disponibles pour ce t√©l√©phone'
);
</script>
++++

== Plus de synonymes

Le mixin `syn` est parfait pour des mots ou des fragments de phrases. Mais √† pr√©sent, nous allons cr√©er des textes d'introduction, et nous voulons une certaine diversit√©.

Mettons toutes ces diff√©rentes introductions dans un mixin d√©di√©:
....
mixin intro
  synz
    syn
      | le #{phone.name} est vraiment un super t√©l√©phone.
    syn
      | j'adore le nouveau #{phone.name}.
    syn
      | le #{phone.name} : un super t√©l√©phone !
....

La structure `synz > syn` liste les alternatives synonymiques. Vous pouvez mettre ce que vous voulez dans chaque alternative (dans chaque `syn`) : des conditions, d'autres synonymes etc.

Appelons ce nouveau mixin :
....
mixin phone
  | #[+intro] .
  | #[+colors] .

- let phone;
each phoneElt in phones
  - phone = phoneElt;
  p #[+phone]
....

Vous devriez avoir : +
_L'OnePlus 5T : un super t√©l√©phone ! Les couleurs disponibles pour ce t√©l√©phone sont Noir, Rouge et Blanc._ +
_J'adore le nouveau OnePlus 5. Les finitions disponibles pour ce t√©l√©phone sont Or et Gris._ +
_L'OnePlus 3T : un super t√©l√©phone ! Les finitions disponibles pour ce t√©l√©phone sont Noir, Or et Gris._

Les introductions sont choisies al√©atoirement : il peut donc y avoir des r√©p√©titions d'un t√©l√©phone √† un autre.

++++
<script>
const mixinIntroString = `
mixin intro
  synz
    syn
      | le #{phone.name} est vraiment un super t√©l√©phone.
    syn
      | j'adore le nouveau #{phone.name}.
    syn
      | le #{phone.name} : un super t√©l√©phone !
`;

const mixinPhoneString = `
mixin phone
  | #[+intro] .
  | #[+colors] .
`;

const main2String = mainString.replace('MAIN', `p #[+phone]`);

spawnEditor(currentLang,
  main2String.replace('BEFORE', [mixinColors2String, mixinIntroString, mixinPhoneString].join('\n')),
  'OnePlus 3T'
);
</script>
++++


N√©anmoins vous avez constat√© que RosaeNLG a g√©n√©r√© _L'OnePlus_, au lieu de _Le OnePlus_. RosaeNLG contient un m√©canisme de contraction automatique (_le arbre_ devient _l'arbre_ etc.), mais qui se d√©clenche parfois de fa√ßon intempestive.

Prot√©gez les noms de t√©l√©phone du m√©canisme de contraction avec `protect` :
....
    syn
      | le
      protect
        | #{phone.name}
      | est vraiment un super t√©l√©phone.
    syn
      | j'adore le nouveau
      protect
        | #{phone.name}      
      | .
    syn
      | le
      protect
        | #{phone.name}
      | : un super t√©l√©phone !
....

Vous devriez √† pr√©sent bien avoir _Le OnePlus 5T..._.

++++
<script>
const mixinIntro2String = `
mixin intro
  synz
    syn
      | le
      protect
        | #{phone.name}
      | est vraiment un super t√©l√©phone.
    syn
      | j'adore le nouveau 
      protect
        | #{phone.name}
      | .
    syn
      | le
      protect
        | #{phone.name}
      | : un super t√©l√©phone !
`;

spawnEditor(currentLang,
  main2String.replace('BEFORE', [mixinColors2String, mixinIntro2String, mixinPhoneString].join('\n')),
  'OnePlus 3T'
);
</script>
++++


== Lister des fragments de phrase

Parlons de l'√©cran : taille et % de couverture. Nous voulons g√©n√©rer _il a un √©cran qui couvre 80.43 % de sa surface et fait 6 pouces_.

Nous pourrions construire une grosse phrase avec plusieurs insertions de valeurs, mais le fait de structurer le code nous donnera plus de flexibilit√©.

Coupons notre grosse phrase en fragments, un pour chaque propri√©t√© :
....
mixin display
  itemz { separator:',', last_separator:'et' }
    item
      | couvre #[+value(phone.screenRatio)] % de sa surface
    item
      | fait #[+value(phone.displaySize)] pouces
....

* `value` est un mixin qui va ins√©rer la valeur dans le r√©sultat, mais en respectant les conventions de formatage de la langue.
* `itemz > item` ressemble √† `synz > syn`, sauf qu'il ne va pas choisir une seule alternative, mais lister tous les √©l√©ments.
* L'objet js apr√®s `itemz` indique √† RosaeNLG comment assembler les √©l√©ments. Il est obligatoire. `separator` et `last_separator` fonctionnent de la m√™me mani√®re que dans la structure `eachz`.

N'oubliez pas d'appeler ce mixin :
....
mixin phone
  | #[+intro] .
  | #[+colors] .
  | #[+display] .
....

Le r√©sultat est honorable, mais il manque le d√©but du texte. Corrigeons cela :
....
mixin display
  itemz { begin_with_general: 'il a un √©cran qui', separator:',', last_separator:'et' }
    item
      | couvre #[+value(phone.screenRatio)] % de sa surface
    item
      | fait #[+value(phone.displaySize)] pouces
....

`begin_with_general` indique √† RosaeNLG comment d√©marrer l'√©num√©ration. Il aurait √©t√© possible de le mettre en-dehors du mixing (juste au-dessus, avec `| il a un √©cran qui`), mais les d√©finir √† l'int√©rieur du mixin est une bonne pratique : par exemple, lorsque la liste est vide (s'il y a des conditions dans chaque `item`), RosaeNLG ne g√©n√®rera pas le contenu pr√©sent dans `begin_with_general`.

Les textes devraient √™tre meilleurs : +
_Le OnePlus 5T est vraiment un super t√©l√©phone. Les finitions disponibles pour ce t√©l√©phone sont Noir, Rouge et Blanc. Il a un √©cran qui couvre 80,43 % de sa surface et fait 6 pouces._ +
_Le OnePlus 5 est vraiment un super t√©l√©phone. Les teintes disponibles pour ce t√©l√©phone sont Or et Gris. Il a un √©cran qui couvre 72,93 % de sa surface et fait 5,5 pouces._ +
_Le OnePlus 3T : un super t√©l√©phone ! Les finitions disponibles pour ce t√©l√©phone sont Noir, Or et Gris. Il a un √©cran qui couvre 73,15 % de sa surface et fait 5,5 pouces._


Ajoutons un peu de fantaisie en m√©langeant les √©l√©ments avec le param√®tre `mix` :
....
mixin display
  itemz { begin_with_general: 'il a un √©cran qui', separator:',', last_separator:'et', mix:true }
    item
      | couvre #[+value(phone.screenRatio)] % de sa surface
    item
      | fait #[+value(phone.displaySize)] pouces
....

_Il a un √©cran qui couvre 80,43 % de sa surface et fait 6 pouces._ +
_Il a un √©cran qui couvre 72,93 % de sa surface et fait 5,5 pouces._ +
_Il a un √©cran qui fait 5,5 pouces et couvre 73,15 % de sa surface._ +

++++
<script>
const mixinDisplayString = `
mixin display
  itemz { begin_with_general: 'il a un √©cran qui', separator:',', last_separator:'et', mix:true }
    item
      | couvre #[+value(phone.screenRatio)] % de sa surface
    item
      | fait #[+value(phone.displaySize)] pouces
`;

const mixinPhone2String = `
mixin phone
  | #[+intro] .
  | #[+colors] .
  | #[+display] .
`;

spawnEditor(currentLang,
  main2String.replace('BEFORE', 
    [mixinColors2String, mixinDisplayString, mixinIntro2String, mixinPhone2String].join('\n')
  ),
  'Il a un √©cran qui'
);
</script>
++++


== Encore plus de vari√©t√©

AJoutez du texte pour parler de la batterie :
....
  | ce t√©l√©phone a une batterie de #[+value(phone.battery)] mAh.
....

Nous avons √† pr√©sent un volume correct de texte. Mais nous aimerions avoir plus de vari√©t√© : nous parlons toujours des couleurs, de l'√©cran puis de la batterie, dans cet ordre, alors que nous pourrions en parler dans n'importe quel ordre. Mettez tous les fragments de texte dans une structure `itemz > item`, et ajoutez un param√®tre `mix` :

....
mixin phone_chunks
  itemz {separator: '.', end:'.', mix:true}
    item
      | #[+colors]
    item
      | #[+display]
    item
      | ce t√©l√©phone a une batterie de #[+value(phone.battery)] mAh.

include::partial$tuto_fr_FR.pug[tags=phoneMixin]
....


++++
<script>
const mixinChunksString = `
mixin phone_chunks
  itemz {separator: '.', end:'.', mix:true}
    item
      | #[+colors]
    item
      | #[+display]
    item
      | ce t√©l√©phone a une batterie de #[+value(phone.battery)] mAh.
`;

const mixinPhone3String = `
mixin phone
  | #[+intro] .
  | #[+phone_chunks]
`;

spawnEditor(currentLang,
  main2String.replace('BEFORE', [mixinColors2String, mixinDisplayString, mixinIntro2String, mixinChunksString, mixinPhone3String].join('\n')),
  't√©l√©phone a une batterie'
);
</script>
++++

== Expressions r√©f√©rentielles

Il y a une structure cach√©e dans la fa√ßon dont nous parlons du t√©l√©phone :

* La 1re fois que l'on en parle, nous utilisons le nom du t√©l√©phone.
* Les fois suivantes, nous utilisons soit `ce t√©l√©phone`, soit `il`.

En NLG (et en linguistique) ce concept est appel√© _expressions r√©f√©rentielles_. La 1re fois que nous parlons de quelque chose, nous utilisons son mode de repr√©sentation _repr√©sentant_ et les fois suivantes nous utilisons sa r√©pr√©sentation sous forme d'_expression r√©f√©rentielle_. Demandons √† RosaeNLG de g√©rer cela automatiquement.

Cr√©ez 2 mixins, un pour chaque type de repr√©sentant :
....
mixin phone_ref(obj, params)
  | le
  protect
    | #{phone.name}

mixin phone_refexpr(obj, params)
  | #[+syn('ce t√©l√©phone', 'il')]
....

TIP: Le 1er param√®tre, `obj`, correspond √† l'objet `phone`. `#{obj.name}` correspond √† `#{phone.name}`.

Pour que cela fonctionne il faut les r√©f√©rencer:
....
include::partial$tuto_fr_FR.pug[tags=main]
....

Nous pouvons les utiliser partout (ou presque):
....
| #[+value(phone)] est vraiment un super t√©l√©phone.

| #[+value(phone)] : un super t√©l√©phone !

| #[+value(phone)] a une batterie de #[+value(phone.battery)] mAh.

| les #[+syn('couleurs', 'teintes', 'finitions')] disponibles pour #[+value(phone)] sont
....

Nous devons changer la structure de `il a un √©cran qui` car nous ne pouvons pas mettre un `value` directement dans la structure `begin_with_general`. Cela doit √™tre soit une string, soit une r√©f√©rence √† un mixin:
....
include::partial$tuto_fr_FR.pug[tags=mixinItHasADisplay]
...
  itemz { begin_with_general: 'itHasADisplay', separator:',', last_separator:'et', mix:true }
....

Voici l√† ce que vous devriez obtenir : +
_Le OnePlus 5T est vraiment un super t√©l√©phone. Il a une batterie de 3 300 mAh. Il a un √©cran qui couvre 80,43 % de sa surface et fait 6 pouces. Les teintes disponibles pour il sont Noir, Rouge et Blanc._ +
_Le OnePlus 5 est vraiment un super t√©l√©phone. Les finitions disponibles pour ce t√©l√©phone sont Or et Gris. Ce t√©l√©phone a un √©cran qui couvre 72,93 % de sa surface et fait 5,5 pouces. Ce t√©l√©phone a une batterie de 3 300 mAh._ +
_J'adore le nouveau OnePlus 3T. Les finitions disponibles pour le OnePlus 3T sont Noir, Or et Gris. Il a une batterie de 3 400 mAh. Ce t√©l√©phone a un √©cran qui fait 5,5 pouces et couvre 73,15 % de sa surface._


++++
<script>
const main3String = mainString.replace('MAIN', 
`
  p
    -
      phone.ref = 'phone_ref';
      phone.refexpr = 'phone_refexpr';
    | #[+phone]
`);

const mixinPhoneRefRefexprString = `
mixin phone_ref(obj, params)
  | le
  protect
    | #{phone.name}
mixin phone_refexpr(obj, params)
  | #[+syn('ce t√©l√©phone', 'il')]
`;

const mixinColors3String =
`mixin colors
  | les #[+syn('couleurs', 'teintes', 'finitions')] disponibles pour #[+value(phone)] sont
  eachz color in phone.colors with { separator:',', last_separator:'et', end:'.' }
    -
      const colorMapping = {
        'Black': 'Noir',
        'Red': 'Rouge',
        'White': 'Blanc',
        'Gold': 'Or',
        'Gray': 'Gris'
      }
    | #{colorMapping[color]}
`;

const mixinIntro3String = `
mixin intro
  synz
    syn
      | #[+value(phone)] est vraiment un super t√©l√©phone.
    syn
      | j'adore le nouveau #{phone.name}.
    syn
      | #[+value(phone)] : un super t√©l√©phone !
`;

const mixinChunks2String = `
mixin phone_chunks
  itemz {separator: '.', end:'.', mix:true}
    item
      | #[+colors]
    item
      | #[+display]
    item
      | #[+value(phone)] a une batterie de #[+value(phone.battery)] mAh.
`;

const mixinDisplay2String = `
mixin itHasADisplay
  | #[+value(phone)] a un √©cran qui
mixin display
  itemz { begin_with_general: 'itHasADisplay', separator:',', last_separator:'et', mix:true }
    item
      | couvre #[+value(phone.screenRatio)] % de sa surface
    item
      | fait #[+value(phone.displaySize)] pouces
`;

spawnEditor(currentLang,
  main3String.replace('BEFORE', [mixinColors3String, mixinDisplay2String, mixinIntro3String, mixinChunks2String, mixinPhoneRefRefexprString, mixinPhone3String].join('\n')),
  'OnePlus'
);
</script>
++++


Le r√©sultat est correct, mais il y a 2 probl√®mes :

. _Les teintes disponibles pour il sont Noir..._ n'est pas correct. `il` ne doit pas √™tre d√©clench√© dans ce contexte.
. Nous n'avons pas pu remplacer `j'adore le nouveau #{phone.name}` : en effet le d√©terminant est avant l'adjectif. Ce n'est pas tr√®s grave, mais on peut avoir le texte suivant _J'adore le nouveau OnePlus 5. Les couleurs disponibles pour le OnePlus 5_ o√π _OnePlus 5_ est r√©p√©t√©.

Il y a plusieurs fa√ßons plus ou moins sophistiqu√©es de r√©gler ces probl√®mes. Une approche directe consiste √† utiliser des param√®tres et des conditions.


== Expressions r√©f√©rentielles conditionn√©es

Nous devons d'abord indiquer, √† l'endroit o√π le `il` intempestif appara√Æt, qu'il n'est pas souhait√©. Rajoutez un param√®tre suppl√©mentaire (un "flag") dans l'appel √† `value` :
....
  | les #[+syn('couleurs', 'teintes', 'finitions')] disponibles pour 
  | #[+value(phone, {'NOT_IL_ELLE':true})] sont
....

Puis :

* utilisez ce param√®tre dans le mixin de l'expression r√©f√©rentielle
* utilisez une structure `synz > syn` au lieu de `syn` afin de pouvoir √©crire la condition

....
mixin phone_refexpr(obj, params)
  synz
    syn
      | ce t√©l√©phone
    syn
      if !hasFlag(params, 'NOT_IL_ELLE')
        | il
....

Le `il` ne doit plus se d√©clencher de fa√ßon inopportune.

TIP: `hasFlag` est un raccourci syntaxique √©quivalent √† `params!=null && params['NOT_IL_ELLE']==true`.

TIP: Lorsqu'un synonyme vide est d√©clench√© (ce qui peut √™tre le cas ici depuis que la condition a √©t√© ajout√©e), RosaeNLG en choisira simplement un autre.


Sur `j'adore le nouveau #{phone.name}`, il s'agit d'√©viter l'affichage du d√©terminant. Rajoutez encore un param√®tre :
....
      | j'adore le nouveau #[+value(phone, {'NO_DET':true})].
....
et exploitez-le :
....
mixin phone_ref(obj, params)
  if !hasFlag(params,'NO_DET')
    | le
  protect
    | #{phone.name}
....

TIP: La ligne vide contenant simplement un pipe `|` sert √† forcer l'ajout d'un espace. Si vous ne le mettez pas, vous aurez _LeOnePlus_. Il est difficile de pr√©voir √† l'avance ces cas - rajoutez simplement un `|` dans une ligne vide lorsqu'ils arrivent.


++++
<script>

const mixinPhoneRefRefexpr2String = `
mixin phone_ref(obj, params)
  if !hasFlag(params,'NO_DET')
    | le
  protect
    | #{phone.name}

mixin phone_refexpr(obj, params)
  synz
    syn
      | ce t√©l√©phone
    syn
      if !hasFlag(params, 'NOT_IL_ELLE')
        | il
`;

const mixinColors4String =
`mixin colors
  | les #[+syn('couleurs', 'teintes', 'finitions')] disponibles pour 
  | #[+value(phone, {'NOT_IL_ELLE':true})] sont
  eachz color in phone.colors with { separator:',', last_separator:'et', end:'.' }
    -
      const colorMapping = {
        'Black': 'Noir',
        'Red': 'Rouge',
        'White': 'Blanc',
        'Gold': 'Or',
        'Gray': 'Gris'
      }
    | #{colorMapping[color]}
`;

const mixinIntro4String = `
mixin intro
  synz
    syn
      | #[+value(phone)] est vraiment un super t√©l√©phone.
    syn
      | j'adore le nouveau #[+value(phone, {'NO_DET':true})].
    syn
      | #[+value(phone)] : un super t√©l√©phone !
`;

spawnEditor(currentLang,
  main3String.replace('BEFORE', [mixinColors4String, mixinDisplay2String, mixinIntro4String, mixinChunks2String, mixinPhoneRefRefexpr2String, mixinPhone3String].join('\n')),
  'OnePlus'
);
</script>
++++


== Textes combin√©s et "has said"

G√©n√©rons des textes plus sophistiqu√©s en combinant, dans une m√™me phrase, les informations sur l'√©cran et celles sur la batterie : _Ce t√©l√©phone a un √©cran qui fait 6 pouces et couvre 80,43 % de sa surface, et dispose par ailleurs d'une batterie de 3 300 mAh._

C'est assez simple :
....
      | #[+display]
      | , et dispose par ailleurs d'une batterie de #[+value(phone.battery)] mAh
....

Le probl√®me est que nous ne souhaitons pas parler deux fois de la batterie. Nous pourrions juste supprimer la phrase habituelle (_Il a une batterie de 3 300 mAh_), mais essayons plut√¥t de ne d√©clencher la phrase sur la batterie que si nous n'avons pas parl√© de la batterie avant. Utilisons pour cela `recordSaid` et `hasSaid`.

....
include::partial$tuto_fr_FR.pug[tags=hasSaid]
....

Le pattern hasSaid/recordSaid, utilis√© 2 fois ici, est le suivant : _si nous n'avons pas encore parl√© de quelque chose :_

. _Nous en parlons_
. _Nous enregistrons le fait d'en avoir parl√©_

TIP: Vous devez utiliser ce m√©canisme int√©gr√© et ne pas vous fier √† des variables ou hashmaps sp√©cifiques, car RosaeNLG va d'avant en arri√®re dans la g√©n√©ration du texte.

TIP: Il faut √©galement faire un `deleteSaid('BATTERY')` dans la boucle principale, car on doit reparler de la batterie sur chacun des t√©l√©phones.

Vous devriez obtenir ces jolies phrases : +
_J'adore le nouveau OnePlus 5T. Ce t√©l√©phone a une batterie de 3 300 mAh. Il a un √©cran qui fait 6 pouces et couvre 80,43 % de sa surface. Les couleurs disponibles pour ce t√©l√©phone sont Noir, Rouge et Blanc._ +
_Le OnePlus 5 : un super t√©l√©phone ! Ce t√©l√©phone a un √©cran qui fait 5,5 pouces et couvre 72,93 % de sa surface, et dispose par ailleurs d'une batterie de 3 300 mAh. Les couleurs disponibles pour ce t√©l√©phone sont Or et Gris._ +
_Le OnePlus 3T : un super t√©l√©phone ! Les teintes disponibles pour ce t√©l√©phone sont Noir, Or et Gris. Il a un √©cran qui fait 5,5 pouces et couvre 73,15 % de sa surface, et dispose par ailleurs d'une batterie de 3 400 mAh._


++++
<script>

const mixinChunks3String = `
mixin phone_chunks
  itemz {separator: '.', end:'.', mix:true}
    item
      | #[+colors]
    item
      | #[+display]
      
      if !hasSaid('BATTERY')
        | , et dispose par ailleurs d'une batterie de #[+value(phone.battery)] mAh
        recordSaid('BATTERY')
    item
      if !hasSaid('BATTERY')
        | #[+value(phone)] a une batterie de #[+value(phone.battery)] mAh
        recordSaid('BATTERY')
`;

const main4String = mainString.replace('MAIN', 
`
  p
    -
      phone.ref = 'phone_ref';
      phone.refexpr = 'phone_refexpr';
    | #[+phone]
    deleteSaid('BATTERY')
`);

spawnEditor(currentLang,
  main4String.replace('BEFORE', [mixinColors4String, mixinDisplay2String, mixinIntro4String, mixinChunks3String, mixinPhoneRefRefexpr2String, mixinPhone3String].join('\n')),
  'OnePlus'
);
</script>
++++


== Encore plus d'expressions r√©f√©rentielles

Nous arrivons √† g√©n√©rer _ce t√©l√©phone_ ou _il_ comme expression r√©f√©rentielle. Essayons d'ajouter _ce t√©l√©phone_, _le t√©l√©phone_, _cet appareil_, _cette machine_.

Il est tr√®s facile d'ajouter des synonymes dans la liste:
....
    syn
      | ce t√©l√©phone
    syn
      | le t√©l√©phone
    syn
      | cet appareil
    syn
      | cette machine
....

H√©las, _machine_ est f√©minin. Vous aurez des textes comme _Cette machine a une batterie de 3 300 mAh. Il a un √©cran..._ qui ne sont pas corrects. Il faut √™tre capables de suivre le changement de genre de l'expression r√©f√©rentielle.

=== Genre explicite

Une premi√®re m√©thode consiste √† l'indiquer explicitement avec `setRefGender`. `setRefGender` indique √† RosaeNLG le genre courant de l'objet :
....
    syn
      | cette machine
      - setRefGender(phone, 'F');
    syn
      | ce t√©l√©phone
      - setRefGender(phone, 'M');
....

Nous pouvons ensuite interroger le genre courant de l'expression r√©f√©rentielle avec `getRefGender` :
....
    syn
      if !hasFlag(params, 'NOT_IL_ELLE')
        if getRefGender(phone)=='M'
          | il
        else
          | elle
....

Nous devrions √©galement expliciter le genre du repr√©sentant :
....
mixin phone_ref(obj, params)
  if !hasFlag(params,'NO_DET')
    | le
  protect
    | #{phone.name}
  - setRefGender(phone, 'M')
....

√Ä pr√©sent les genres sont respect√©s : _Les couleurs disponibles pour cette machine sont Noir, Rouge et Blanc. Elle a un √©cran qui couvre 80,43 % de sa surface et fait 6 pouces._

La structure `getRefGender` d√©clenchant _il_ ou _elle_ suivant le genre est tr√®s classique et il existe un raccourci :
....
      if !hasFlag(params, 'NOT_IL_ELLE')
        | #{getMorF(['il', 'elle'], phone)}
....


++++
<script>
const mixinPhoneRefRefexpr3String = `
mixin phone_ref(obj, params)
  if !hasFlag(params,'NO_DET')
    | le
  protect
    | #{phone.name}
  - setRefGender(phone, 'M')

mixin phone_refexpr(obj, params)
  synz
    syn
      | cette machine
      - setRefGender(phone, 'F');
    syn
      if !hasFlag(params, 'NOT_IL_ELLE')
        | #{getMorF(['il', 'elle'], phone)}
    syn
      | ce t√©l√©phone
      - setRefGender(phone, 'M');
`;

spawnEditor(currentLang,
  main4String.replace('BEFORE', [mixinColors4String, mixinDisplay2String, mixinIntro4String, mixinChunks3String, mixinPhoneRefRefexpr3String, mixinPhone3String].join('\n')),
  'OnePlus'
);
</script>
++++

=== Dictionnaire pour le genre

Il est courant de faire des erreurs lorsqu'on indique le genre. Il est pr√©f√©rable de faire appel au dictionnaire int√©gr√© de RosaeNLG (d√©riv√© du lefff) pour trouver le genre :
....
    syn
      | cette machine
      - setRefGender(phone, 'machine');
    syn
      | ce t√©l√©phone
      - setRefGender(phone, 't√©l√©phone');
....


Il existe un raccourci syntaxique permettant :

. d'afficher un mot
. de rechercher son genre dans le dictionnaire
. d'enregistrer son genre courant

....
    syn
      | cette #[+value('machine', {represents: phone})]
    syn
      | ce #[+value('t√©l√©phone', {represents: phone})]
....


++++
<script>
const mixinPhoneRefRefexpr4String = `
mixin phone_ref(obj, params)
  if !hasFlag(params,'NO_DET')
    | le
  protect
    | #{phone.name}
  - setRefGender(phone, 'M')

mixin phone_refexpr(obj, params)
  synz
    syn
      | cette #[+value('machine', {represents: phone})]
    syn
      | ce #[+value('t√©l√©phone', {represents: phone})]
    syn
      if !hasFlag(params, 'NOT_IL_ELLE')
        | #{getMorF(['il', 'elle'], phone)}
`;

spawnEditor(currentLang,
  main4String.replace('BEFORE', [mixinColors4String, mixinDisplay2String, mixinIntro4String, mixinChunks3String, mixinPhoneRefRefexpr4String, mixinPhone3String].join('\n')),
  'OnePlus'
);
</script>
++++


== D√©terminant automatique

G√©n√©rons automatiquement le d√©terminant. ce/cette sont des pronoms d√©monstratifs, le/la sont des articles d√©finis :
....
    syn
      | #[+value('t√©l√©phone', {represents: phone, det: 'DEMONSTRATIVE'})]
    syn
      | #[+value('t√©l√©phone', {represents: phone, det: 'DEFINITE'})]
    syn
      | #[+value('machine', {represents: phone, det: 'DEMONSTRATIVE'})]
    syn
      | #[+value('appareil', {represents: phone, det: 'DEMONSTRATIVE'})]
....

Ce n'est pas indispensable, mais cela permet ensuite de mutualiser facilement des alternatives gr√¢ce √† `syn_fct`. `syn_fct` est une fonction qui renvoie al√©atoirement un √©l√©ment d'un tableau :
....
    syn
      | #[+value('t√©l√©phone', {represents: phone, det: syn_fct(['DEFINITE', 'DEMONSTRATIVE'])})]
....

TIP: RosaeNLG g√®re automatiquement les h aspir√©s : _cet hebdomadaire_ / _ce h√©risson_.

++++
<script>
const mixinPhoneRefRefexpr5String = `
mixin phone_ref(obj, params)
  if !hasFlag(params,'NO_DET')
    | le
  protect
    | #{phone.name}
  - setRefGender(phone, 'M')

mixin phone_refexpr(obj, params)
  synz
    syn
      | #[+value('t√©l√©phone', {represents: phone, det: syn_fct(['DEFINITE', 'DEMONSTRATIVE'])})]
    syn
      | #[+value('appareil', {represents: phone, det: syn_fct(['DEFINITE', 'DEMONSTRATIVE'])})]
    syn
      | #[+value('machine', {represents: phone, det: 'DEMONSTRATIVE'})]
    syn
      if !hasFlag(params, 'NOT_IL_ELLE')
        | #{getMorF(['il', 'elle'], phone)}
`;

spawnEditor(currentLang,
  main4String.replace('BEFORE', [mixinColors4String, mixinDisplay2String, mixinIntro4String, mixinChunks3String, mixinPhoneRefRefexpr5String, mixinPhone3String].join('\n')),
  'OnePlus'
);
</script>
++++


== Syntaxe simplifi√©e

Il est peut √™tre laborieux de devoir d√©couper les groupes nominaux en d√©terminant, adjectif et nom. Utilisez la syntaxe simplifi√©e avec `<...>` :
....
    syn
      | #[+value('<ce appareil>', {represents: phone})]
    syn
      | #[+value('<cette machine>', {represents: phone})]
    syn
      | #[+value('<ce t√©l√©phone>', {represents: phone})]
    syn
      | #[+value('<le t√©l√©phone>', {represents: phone})]
....

RosaeNLG g√®rera automatiquement :

* le choix du bon article
* les accords en genre et en nombre : `<des bon g√¢teaux P>` => _des bons g√¢teaux_
* les contractions : `<le arbre>` => _l'arbre_
* le h muet : `<la vieux homme>` => _le vieil homme_

TIP: Inutile de faire les accords avec la syntaxe `<...>`. `<ce appareil>`, `<cet appareil>`, `<cette appareil>` sont √©quivalents.

TIP: La syntaxe simplifi√©e ne marche pas dans un navigateur car elle n√©cessiterait trop de ressources linguistiques embarqu√©es.


== Changer le mode de synonyme

Nous avons parfois ce type de r√©sultat : +
_Les finitions disponibles pour ce t√©l√©phone fabuleux sont Noir, Or et Gris. Le t√©l√©phone a un √©cran ..._

_t√©l√©phone_ est r√©p√©t√© ce qui n'est pas parfait. Au lieu de choisir les synonymes al√©atoirement, d√©clenchons-les en s√©quence, ce qui √©vitera les r√©p√©titions proches :
....
mixin phone_re(obj, params)
  synz {mode:'sequence'}
    syn
      ...
....

Nous aurons moins de r√©p√©titions : +
_J'adore le nouveau OnePlus 3T. Ce t√©l√©phone a une batterie de 3 400 mAh. Les couleurs disponibles pour cette machine exceptionnelle sont Noir, Or et Gris. Cet appareil a un √©cran qui couvre 73,15 % de sa surface et fait 5,5 pouces._


++++
<script>
const mixinPhoneRefRefexpr6String = `
mixin phone_ref(obj, params)
  if !hasFlag(params,'NO_DET')
    | le
  protect
    | #{phone.name}
  - setRefGender(phone, 'M')

mixin phone_refexpr(obj, params)
  synz {mode:'sequence'}
    syn
      | #[+value('t√©l√©phone', {represents: phone, det: syn_fct(['DEFINITE', 'DEMONSTRATIVE'])})]
    syn
      | #[+value('machine', {represents: phone, det: 'DEMONSTRATIVE'})]
    syn
      if !hasFlag(params, 'NOT_IL_ELLE')
        | #{getMorF(['il', 'elle'], phone)}
    syn
      | #[+value('appareil', {represents: phone, det: syn_fct(['DEFINITE', 'DEMONSTRATIVE'])})]
`;

spawnEditor(currentLang,
  main4String.replace('BEFORE', [mixinColors4String, mixinDisplay2String, mixinIntro4String, mixinChunks3String, mixinPhoneRefRefexpr6String, mixinPhone3String].join('\n')),
  'e t√©l√©phone'
);
</script>
++++


== Accord de l'adjectif

Ajoutons un adjectif lorsqu'on parle des couleurs : _les couleurs disponibles pour ce t√©l√©phone exceptionnel sont..._.

_exceptionnel_ doit √™tre accord√© avec le r√©pr√©sentant : _ce t√©l√©phone exceptionnel_ / _cette machine exceptionnelle_. Nous pourrions utiliser `getRefGender` et une condition, mais RosaeNLG sait accorder les adjectifs :
....
  | les #[+syn('couleurs', 'teintes', 'finitions')] disponibles pour 
  | #[+value(phone, {'NOT_IL_ELLE':true})] 
  | #[+agreeAdj('exceptionnel', phone)]
  | sont
....

Ajoutons de la vari√©t√© :
....
  | #[+agreeAdj(syn_fct(['exceptionnel','fabuleux','singulier']), phone)]
....
Cela g√©n√®rera _cette machine fabuleuse_, _cette machine singuli√®re_, etc.

TIP: La syntaxe simplifi√©e fonctionne avec les adjectifs: `<ce machine fabuleux>` g√©n√®rera `<cette machine fabuleuse>`. Vous pouvez essayer d'int√©grer des adjectifs directement dans `phone_refexpr`.



++++
<script>
const mixinColors5String =
`mixin colors
  | les #[+syn('couleurs', 'teintes', 'finitions')] disponibles pour 
  | #[+value(phone, {'NOT_IL_ELLE':true})] 
  | #[+agreeAdj(syn_fct(['exceptionnel','fabuleux','singulier']), phone)]
  | sont
  eachz color in phone.colors with { separator:',', last_separator:'et', end:'.' }
    -
      const colorMapping = {
        'Black': 'Noir',
        'Red': 'Rouge',
        'White': 'Blanc',
        'Gold': 'Or',
        'Gray': 'Gris'
      }
    | #{colorMapping[color]}
`;

spawnEditor(currentLang,
  main4String.replace('BEFORE', [mixinColors5String, mixinDisplay2String, mixinIntro4String, mixinChunks3String, mixinPhoneRefRefexpr6String, mixinPhone3String].join('\n')),
  'OnePlus'
);
</script>
++++


== F√©licitations !

Vous avez termin√© le tutoriel.

*Toutes mes f√©licitations !* üéÜ


== Encore plus

Nous avons vu quelques aspects de NLG √† travers ce tutoriel.
Il y a d'autres fonctionnalit√©s que vous pouvez explorer, comme par exemple :

* la gestion des possessifs
* l'accord des verbes
* l'affichage et le formatage des dates et des nombres
* etc.


== Version finale du code

`tuto.js`
[source,javascript]
[subs=attributes+]
....
include::partial$tuto_fragments.js[tags=require]
include::partial$tuto_fragments.js[tags=data]
include::partial$tuto_fragments.js[tags=mainLoop]
....

`tuto.pug`
....
include::partial$tuto_fr_FR.pug[]
....
